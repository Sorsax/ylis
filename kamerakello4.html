<!DOCTYPE html>
<html lang="fi">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Kamera Tracker</title>
<link href="https://fonts.googleapis.com/css2?family=Bree+Serif&display=swap" rel="stylesheet" />
<style>
  /* ...keep your CSS, but add red timer styling... */
  .timer-red { color: red !important; }
</style>
</head>
<body>
<header>
  <div id="mainTimer">03:00</div>
  <button id="settingsToggle" onclick="toggleSettings()">⚙ Asetukset</button>
</header>

<main>
  <div id="cameraContainer"></div>
</main>

<footer id="status" class="fail">vMix: Ei yhteyttä</footer>

<div id="settingsPanel">
  <h2>Asetukset</h2>
  <label>vMix IP:<br><input type="text" id="vmixIp" /></label>
  <label>Ajastimen pituus (sekuntia):<br><input type="number" id="timerLength" min="1" /></label>
  <label>Vaihda punaiseksi kun aikaa jäljellä (sekuntia):<br>
    <input type="number" id="warningThreshold" min="1" value="20" />
  </label>
  <button onclick="applySettings()">Tallenna asetukset</button>

  <hr />
  <h3>Lisää kamera</h3>
  <label>Nimi:<br><input type="text" id="camName" /></label>
  <label>vMix Input:<br><input type="text" id="camInput" /></label>
  <button onclick="addCamera()">Lisää kamera</button>

  <hr />
  <h3>Kategoriat</h3>
  <div class="category-list" id="categoryList"></div>
  <label>Uusi kategoria:<br><input type="text" id="newCategoryName" /></label>
  <button onclick="addCategory()">Lisää kategoria</button>

  <hr />
  <button style="background:#a00; color:#fff;" onclick="resetAll()">Tyhjennä kaikki asetukset</button>
</div>

<script>
  // --- Data ---
  let vmixIp = '127.0.0.1';
  let timerDuration = 180; // sekunteina (main timer)
  let warningThreshold = 20; // sekunteina
  let cameras = [];
  let categories = [];
  let programInput = null;
  let previewInput = null;
  let mainTimer = timerDuration;

  // [NEW] Camera timers:
  // Add to each camera:
  //  - totalProgramTime: total accumulated seconds in program
  //  - currentProgramTime: current run in program (resets when camera leaves program)
  //  - inProgram: boolean, is currently in program

  // --- Utility ---
  function formatTime(s) {
    const m = Math.floor(s / 60).toString().padStart(2, '0');
    const sec = (s % 60).toString().padStart(2, '0');
    return `${m}:${sec}`;
  }

  // --- Load / Save ---
  function saveToStorage() {
    localStorage.setItem('vmixIp', vmixIp);
    localStorage.setItem('timerDuration', timerDuration);
    localStorage.setItem('warningThreshold', warningThreshold);
    localStorage.setItem('cameras', JSON.stringify(cameras));
    localStorage.setItem('categories', JSON.stringify(categories));
  }
  function loadFromStorage() {
    vmixIp = localStorage.getItem('vmixIp') || '127.0.0.1';
    timerDuration = parseInt(localStorage.getItem('timerDuration')) || 180;
    warningThreshold = parseInt(localStorage.getItem('warningThreshold')) || 20;
    cameras = JSON.parse(localStorage.getItem('cameras') || '[]');
    categories = JSON.parse(localStorage.getItem('categories') || '[]');
  }

  // --- Settings Panel ---
  function toggleSettings() {
    const panel = document.getElementById('settingsPanel');
    panel.classList.toggle('open');
    if (panel.classList.contains('open')) loadSettingsToUI();
  }
  function loadSettingsToUI() {
    document.getElementById('vmixIp').value = vmixIp;
    document.getElementById('timerLength').value = timerDuration;
    document.getElementById('warningThreshold').value = warningThreshold;
    document.getElementById('camName').value = '';
    document.getElementById('camInput').value = '';
    updateCategoryListUI();
  }
  function applySettings() {
    vmixIp = document.getElementById('vmixIp').value.trim() || '127.0.0.1';
    const len = parseInt(document.getElementById('timerLength').value);
    if (len > 0) timerDuration = len;
    warningThreshold = parseInt(document.getElementById('warningThreshold').value) || 20;
    mainTimer = timerDuration;
    saveToStorage();
    updateTimerDisplay();
    alert('Asetukset tallennettu');
  }

  // --- Categories (unchanged except for removing category from camera box display)---
  function addCategory() {
    const newCat = document.getElementById('newCategoryName').value.trim();
    if (!newCat) { alert('Anna kategorian nimi'); return; }
    if (categories.includes(newCat)) { alert('Kategoria on jo olemassa'); return; }
    categories.push(newCat);
    saveToStorage();
    updateCategoryListUI();
    document.getElementById('newCategoryName').value = '';
  }
  function removeCategory(cat) {
    if (!confirm(`Poistetaanko kategoria '${cat}'? Tämä poistaa myös siihen kuuluvat kamerat.`)) return;
    categories = categories.filter(c => c !== cat);
    cameras = cameras.filter(cam => cam.category !== cat);
    saveToStorage();
    updateCategoryListUI();
    renderCameras();
  }
  function updateCategoryListUI() {
    const div = document.getElementById('categoryList');
    div.innerHTML = '';
    for (const cat of categories) {
      const row = document.createElement('div');
      const label = document.createElement('span');
      label.textContent = cat;
      const btn = document.createElement('button');
      btn.textContent = 'X';
      btn.title = `Poista kategoria '${cat}'`;
      btn.onclick = () => removeCategory(cat);
      row.appendChild(label);
      row.appendChild(btn);
      div.appendChild(row);
    }
  }

  // --- Cameras ---
  function addCamera() {
    const name = document.getElementById('camName').value.trim();
    const input = document.getElementById('camInput').value.trim();
    if (!name || !input) { alert('Anna kameran nimi ja vMix Input'); return; }
    if (cameras.find(c => c.input === input)) { alert('Tämä vMix Input on jo lisätty kameraksi.'); return; }
    cameras.push({
      name,
      input,
      category: null, // categories are not shown in camera boxes
      totalProgramTime: 0,
      currentProgramTime: 0,
      inProgram: false
    });
    saveToStorage();
    renderCameras();
    document.getElementById('camName').value = '';
    document.getElementById('camInput').value = '';
  }
  function removeCamera(input) {
    if (!confirm(`Poistetaanko kamera, jonka vMix Input on '${input}'?`)) return;
    cameras = cameras.filter(c => c.input !== input);
    saveToStorage();
    renderCameras();
  }

  // --- Render Cameras ---
  function renderCameras() {
    const container = document.getElementById('cameraContainer');
    container.innerHTML = '';
    // Just a flat list, grouped by category if you wish, but no category label in the box
    const allCams = cameras;
    const camRow = document.createElement('div');
    camRow.className = 'camera-row';
    for (const cam of allCams) {
      camRow.appendChild(createCameraElement(cam));
    }
    container.appendChild(camRow);
  }
  function createCameraElement(cam) {
    const div = document.createElement('div');
    div.className = 'camera none';
    div.dataset.input = cam.input;
    // Kameran nimi ja input
    const title = document.createElement('div');
    title.textContent = cam.name;
    title.style.fontWeight = 'bold';
    div.appendChild(title);

    const inputDiv = document.createElement('div');
    inputDiv.textContent = `Input: ${cam.input}`;
    div.appendChild(inputDiv);

    // NO category display here

    // Timers
    const timersDiv = document.createElement('div');
    timersDiv.style.marginTop = "10px";
    timersDiv.innerHTML = `
      <div>Kokonaisaika ohjelmassa: <span class="cam-total-timer">${formatTime(cam.totalProgramTime||0)}</span></div>
      <div>Nykyinen aika ohjelmassa: <span class="cam-current-timer">00:00</span></div>
    `;
    div.appendChild(timersDiv);

    const btn = document.createElement('button');
    btn.className = 'remove-btn';
    btn.textContent = '×';
    btn.title = 'Poista kamera';
    btn.onclick = () => removeCamera(cam.input);
    div.appendChild(btn);

    return div;
  }

  // --- Camera Timer Management ---
  function updateCameraTimers() {
    let changed = false;
    for (const cam of cameras) {
      if (cam.input === programInput) {
        if (!cam.inProgram) {
          cam.inProgram = true;
          cam.currentProgramTime = 0;
        } else {
          cam.currentProgramTime++;
        }
        cam.totalProgramTime = (cam.totalProgramTime||0) + 1;
        changed = true;
      } else {
        if (cam.inProgram) changed = true;
        cam.inProgram = false;
        cam.currentProgramTime = 0;
      }
    }
    if (changed) saveToStorage();
    updateCameraTimerDisplays();
  }

  function updateCameraTimerDisplays() {
    for (const cam of cameras) {
      const el = document.querySelector(`.camera[data-input="${cam.input}"]`);
      if (!el) continue;
      // Set timer text
      el.querySelector('.cam-total-timer').textContent = formatTime(cam.totalProgramTime||0);
      const curr = cam.inProgram ? cam.currentProgramTime : 0;
      const currTimerSpan = el.querySelector('.cam-current-timer');
      currTimerSpan.textContent = formatTime(curr);

      // Color when below threshold (if in program and time left < threshold)
      if (cam.inProgram && (timerDuration - curr) <= warningThreshold) {
        currTimerSpan.classList.add('timer-red');
      } else {
        currTimerSpan.classList.remove('timer-red');
      }
    }
  }

  // --- Timer ---
  function updateTimerDisplay() {
    const timerDiv = document.getElementById('mainTimer');
    timerDiv.textContent = formatTime(mainTimer);
    if (mainTimer === 0) {
      timerDiv.classList.add('blinking');
    } else {
      timerDiv.classList.remove('blinking');
    }
  }
  function tickTimer() {
    if (mainTimer > 0) {
      mainTimer--;
      updateTimerDisplay();
    }
    updateCameraTimers(); // update program timers every second
  }

  // --- vMix API Polling ---
  async function pollVmix() {
    try {
      const res = await fetch(`http://${vmixIp}:8088/api/`);
      if (!res.ok) throw new Error('HTTP ' + res.status);
      const text = await res.text();
      const parser = new DOMParser();
      const xml = parser.parseFromString(text, 'text/xml');
      const program = xml.querySelector('active');
      const preview = xml.querySelector('preview');
      if (program && preview) {
        programInput = program.textContent;
        previewInput = preview.textContent;
        updateCameraStatus();
        updateStatus('Yhteys: OK', true);
      } else {
        updateStatus('vMix API vastasi, mutta ei löytynyt tietoja', false);
      }
    } catch (e) {
      updateStatus(`Virhe vMix-yhteydessä: ${e.message}`, false);
    }
  }

  function updateStatus(msg, ok) {
    const status = document.getElementById('status');
    status.textContent = msg;
    status.className = ok ? 'ok' : 'fail';
  }

  // --- Päivitä kameroiden tilat ---
  function updateCameraStatus() {
    // Päivitä luokka ja timerit
    for (const cam of cameras) {
      const el = document.querySelector(`.camera[data-input="${cam.input}"]`);
      if (!el) continue;
      el.classList.remove('program', 'preview', 'none');
      if (cam.input === programInput) {
        el.classList.add('program');
      } else if (cam.input === previewInput) {
        el.classList.add('preview');
      } else {
        el.classList.add('none');
      }
    }
    updateCameraTimerDisplays();
  }

  // --- Reset all ---
  function resetAll() {
    if (!confirm('Haluatko varmasti tyhjentää kaikki asetukset ja kamerat?')) return;
    localStorage.clear();
    vmixIp = '127.0.0.1';
    timerDuration = 180;
    warningThreshold = 20;
    mainTimer = timerDuration;
    cameras = [];
    categories = [];
    programInput = null;
    previewInput = null;
    updateTimerDisplay();
    renderCameras();
    updateCategoryListUI();
    updateStatus('Kaikki asetukset tyhjennetty', true);
  }

  // --- Init ---
  function init() {
    loadFromStorage();
    updateTimerDisplay();
    renderCameras();
    updateCategoryListUI();
    setInterval(pollVmix, 1000);
    setInterval(tickTimer, 1000);
  }

  init();
</script>
</body>
</html>
